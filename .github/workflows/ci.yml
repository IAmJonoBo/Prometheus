name: CI

# Dual-environment CI pipeline that works on BOTH GitHub.com and GHES
# (air-gapped). Detects environment via $GITHUB_SERVER_URL and adapts
# registry endpoints, caching strategy, and artifact handling accordingly.

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: read
  packages: write

env:
  # Override these via repository secrets/variables if needed
  RETENTION_DAYS: 30
  IMAGE_NAME: app
  # Skip LFS smudge for faster checkout; fetch explicitly if needed
  GIT_LFS_SKIP_SMUDGE: "1"

jobs:
  build:
    name: Build and package
    runs-on: ubuntu-latest
    outputs:
      registry: ${{ steps.env-detect.outputs.registry }}
      image-tag: ${{ steps.env-detect.outputs.image-tag }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          clean: true
          fetch-depth: 0
          lfs: false

      # Detect GitHub.com vs GHES environment
      - name: Detect environment
        id: env-detect
        shell: bash
        run: |
          SERVER_URL="${GITHUB_SERVER_URL:-https://github.com}"
          echo "server-url=${SERVER_URL}" >> $GITHUB_OUTPUT
          
          # Determine registry endpoint based on server URL
          if [[ "${SERVER_URL}" == "https://github.com" ]]; then
            REGISTRY="ghcr.io"
          else
            # Extract hostname from GHES URL and derive container registry
            HOSTNAME=$(echo "${SERVER_URL}" | sed -E 's#https?://##; s#/.*##')
            REGISTRY="containers.${HOSTNAME}"
          fi
          echo "registry=${REGISTRY}" >> $GITHUB_OUTPUT
          
          # Derive image tag from commit SHA
          IMAGE_TAG="${REGISTRY}/${{ github.repository }}/${IMAGE_NAME}:${{ github.sha }}"
          echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          
          echo "Detected registry: ${REGISTRY}"
          echo "Image tag: ${IMAGE_TAG}"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: pip
          cache-dependency-path: pyproject.toml

      # Language-aware caching: only enable if local caches exist
      - name: Check for pip cache
        id: pip-cache-check
        run: |
          if pip cache info >/dev/null 2>&1; then
            echo "available=true" >> $GITHUB_OUTPUT
          else
            echo "available=false" >> $GITHUB_OUTPUT
          fi

      - name: Install build dependencies
        run: |
          python -m pip install --upgrade pip build wheel
          # Install project dependencies if pyproject.toml present
          if [ -f pyproject.toml ]; then
            pip install -e . || echo "::warning::Could not install project"
          fi

      # Build deliverables to ./dist
      - name: Build project
        run: |
          mkdir -p dist
          python -m build --outdir dist || echo "::warning::Build step incomplete"
          # Placeholder: add actual build commands (npm, make, etc.) as needed
          echo "Build timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)" > dist/BUILD_INFO

      - name: Verify dist contents
        run: |
          echo "Contents of dist/:"
          ls -lh dist/ || echo "dist/ is empty"

      # Upload artifact with actions/upload-artifact@v4
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: app_bundle
          path: dist/
          retention-days: ${{ env.RETENTION_DAYS }}
          if-no-files-found: warn

  publish:
    name: Publish container image
    needs: build
    runs-on: ubuntu-latest
    # Only run if Docker is available; gracefully skip otherwise
    if: ${{ always() }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          clean: true
          fetch-depth: 1
          lfs: false

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: app_bundle
          path: dist/

      - name: Check Docker availability
        id: docker-check
        shell: bash
        run: |
          if command -v docker >/dev/null 2>&1; then
            echo "available=true" >> $GITHUB_OUTPUT
            docker --version
          else
            echo "available=false" >> $GITHUB_OUTPUT
            echo "::warning::Docker not available; skipping container publish"
          fi

      # GHES branch: use native docker login if Marketplace actions unavailable
      - name: Log in to container registry (native)
        if: steps.docker-check.outputs.available == 'true'
        shell: bash
        env:
          REGISTRY: ${{ needs.build.outputs.registry }}
        run: |
          # Use helper script for offline-friendly docker login
          bash scripts/ci/docker-login.sh \
            "${REGISTRY}" \
            "${{ github.actor }}" \
            "${{ secrets.GITHUB_TOKEN }}"

      - name: Build container image
        if: steps.docker-check.outputs.available == 'true'
        shell: bash
        env:
          IMAGE_TAG: ${{ needs.build.outputs.image-tag }}
        run: |
          # Create minimal Dockerfile if not present
          if [ ! -f Dockerfile ]; then
            cat > Dockerfile <<'EOF'
          FROM python:3.11-slim
          WORKDIR /app
          COPY dist/ /app/dist/
          RUN echo "Container built at $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          CMD ["python", "--version"]
          EOF
          fi
          
          docker build -t "${IMAGE_TAG}" .
          echo "Built image: ${IMAGE_TAG}"

      - name: Push container image
        if: steps.docker-check.outputs.available == 'true'
        shell: bash
        env:
          IMAGE_TAG: ${{ needs.build.outputs.image-tag }}
        run: |
          docker push "${IMAGE_TAG}" || {
            echo "::warning::docker push failed; check registry permissions"
            exit 0
          }
          echo "Pushed image: ${IMAGE_TAG}"

  consume:
    name: Consumer job (restricted runners)
    needs: [build, publish]
    runs-on: ubuntu-latest
    if: ${{ always() }}
    steps:
      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: app_bundle
          path: /tmp/payload

      - name: Install from artifact
        shell: bash
        run: |
          echo "Installing from /tmp/payload"
          ls -lh /tmp/payload/
          # Placeholder: add actual install commands as needed
          if [ -f /tmp/payload/BUILD_INFO ]; then
            cat /tmp/payload/BUILD_INFO
          fi

      - name: Demonstrate docker pull path
        if: needs.publish.result == 'success'
        shell: bash
        env:
          IMAGE_TAG: ${{ needs.build.outputs.image-tag }}
        run: |
          if command -v docker >/dev/null 2>&1; then
            echo "Attempting to pull ${IMAGE_TAG}"
            docker pull "${IMAGE_TAG}" || {
              echo "::notice::Image pull failed or not available"
            }
          else
            echo "::notice::Docker not available on consumer runner"
          fi
