name: CI

# Dual-environment CI pipeline that works on BOTH GitHub.com and GHES
# (air-gapped). Detects environment via $GITHUB_SERVER_URL and adapts
# registry endpoints, caching strategy, and artifact handling accordingly.

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:
  schedule:
    # Run dependency check weekly on Mondays at 9:00 UTC
    - cron: '0 9 * * 1'

permissions:
  contents: read
  packages: write

env:
  # Override these via repository secrets/variables if needed
  RETENTION_DAYS: 30
  IMAGE_NAME: app
  # Skip LFS smudge for faster checkout; fetch explicitly if needed
  GIT_LFS_SKIP_SMUDGE: "1"

jobs:
  build:
    name: Build and package
    runs-on: ubuntu-latest
    outputs:
      registry: ${{ steps.env-detect.outputs.registry }}
      image-tag: ${{ steps.env-detect.outputs.image-tag }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          clean: true
          fetch-depth: 0
          lfs: false

      # Detect GitHub.com vs GHES environment
      - name: Detect environment
        id: env-detect
        shell: bash
        run: |
          SERVER_URL="${GITHUB_SERVER_URL:-https://github.com}"
          echo "server-url=${SERVER_URL}" >> $GITHUB_OUTPUT
          
          # Determine registry endpoint based on server URL
          if [[ "${SERVER_URL}" == "https://github.com" ]]; then
            REGISTRY="ghcr.io"
          else
            # Extract hostname from GHES URL and derive container registry
            HOSTNAME=$(echo "${SERVER_URL}" | sed -E 's#https?://##; s#/.*##')
            REGISTRY="containers.${HOSTNAME}"
          fi
          echo "registry=${REGISTRY}" >> $GITHUB_OUTPUT
          
          # Derive image tag from commit SHA (convert repository to lowercase)
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          IMAGE_TAG="${REGISTRY}/${REPO_LOWER}/${IMAGE_NAME}:${{ github.sha }}"
          echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          
          echo "Detected registry: ${REGISTRY}"
          echo "Image tag: ${IMAGE_TAG}"

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          # Disable cache by default; air-gapped environments handle it via vendored deps
          cache: ""

      # Language-aware caching: only enable if explicitly requested
      - name: Cache pip dependencies (conditional)
        id: pip-cache
        uses: actions/cache@v4
        if: ${{ !env.ACT }}  # Skip in local testing
        continue-on-error: true
        with:
          path: |
            ~/.cache/pip
            ~/.local/share/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/poetry.lock', '**/pyproject.toml') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install build dependencies
        run: |
          python -m pip install --upgrade pip
          pip install build wheel poetry==2.2.0

      # Use Poetry for dependency management (this is a Poetry project)
      - name: Install project dependencies
        continue-on-error: true
        run: |
          if [ -f poetry.lock ]; then
            echo "Installing dependencies with Poetry..."
            poetry install --no-root --only main || {
              echo "::warning::Poetry install failed; continuing with build-only deps"
            }
          fi

      # Build deliverables to ./dist
      - name: Build project
        run: |
          mkdir -p dist
          # Use Poetry to build if available, fallback to python -m build
          if command -v poetry >/dev/null 2>&1 && [ -f poetry.lock ]; then
            poetry build --format wheel --output dist || python -m build --outdir dist
          else
            python -m build --outdir dist || echo "::warning::Build step incomplete"
          fi
          # Add build metadata
          echo "Build timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)" > dist/BUILD_INFO
          echo "Git SHA: ${GITHUB_SHA:-unknown}" >> dist/BUILD_INFO

      - name: Verify dist contents
        run: |
          echo "Contents of dist/:"
          ls -lh dist/ || echo "dist/ is empty"

      # Upload artifact with actions/upload-artifact@v4
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: app_bundle
          path: dist/
          retention-days: ${{ env.RETENTION_DAYS }}
          if-no-files-found: warn

  publish:
    name: Publish container image
    needs: build
    runs-on: ubuntu-latest
    # Only run if Docker is available; gracefully skip otherwise
    if: ${{ always() }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          clean: true
          fetch-depth: 1
          lfs: false

      - name: Download build artifacts
        uses: actions/download-artifact@v5
        with:
          name: app_bundle
          path: dist/

      - name: Check Docker availability
        id: docker-check
        shell: bash
        run: |
          if command -v docker >/dev/null 2>&1; then
            echo "available=true" >> $GITHUB_OUTPUT
            docker --version
          else
            echo "available=false" >> $GITHUB_OUTPUT
            echo "::warning::Docker not available; skipping container publish"
          fi

      # GHES branch: use native docker login if Marketplace actions unavailable
      - name: Log in to container registry (native)
        if: steps.docker-check.outputs.available == 'true'
        shell: bash
        env:
          REGISTRY: ${{ needs.build.outputs.registry }}
        run: |
          # Use helper script for offline-friendly docker login
          bash scripts/ci/docker-login.sh \
            "${REGISTRY}" \
            "${{ github.actor }}" \
            "${{ secrets.GITHUB_TOKEN }}"

      - name: Build container image
        if: steps.docker-check.outputs.available == 'true'
        shell: bash
        env:
          IMAGE_TAG: ${{ needs.build.outputs.image-tag }}
        run: |
          # Create minimal Dockerfile if not present
          if [ ! -f Dockerfile ]; then
            cat > Dockerfile <<'EOF'
          FROM python:3.11-slim
          WORKDIR /app
          COPY dist/ /app/dist/
          RUN echo "Container built at $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          CMD ["python", "--version"]
          EOF
          fi
          
          docker build -t "${IMAGE_TAG}" .
          echo "Built image: ${IMAGE_TAG}"

      - name: Push container image
        if: steps.docker-check.outputs.available == 'true'
        shell: bash
        env:
          IMAGE_TAG: ${{ needs.build.outputs.image-tag }}
        run: |
          docker push "${IMAGE_TAG}" || {
            echo "::warning::docker push failed; check registry permissions"
            exit 0
          }
          echo "Pushed image: ${IMAGE_TAG}"

  consume:
    name: Consumer job (restricted runners)
    needs: [build, publish]
    runs-on: ubuntu-latest
    if: ${{ always() }}
    steps:
      - name: Download artifact
        uses: actions/download-artifact@v5
        with:
          name: app_bundle
          path: /tmp/payload

      - name: Install from artifact
        shell: bash
        run: |
          echo "Installing from /tmp/payload"
          ls -lh /tmp/payload/
          # Placeholder: add actual install commands as needed
          if [ -f /tmp/payload/BUILD_INFO ]; then
            cat /tmp/payload/BUILD_INFO
          fi

      - name: Demonstrate docker pull path
        if: needs.publish.result == 'success'
        shell: bash
        env:
          IMAGE_TAG: ${{ needs.build.outputs.image-tag }}
        run: |
          if command -v docker >/dev/null 2>&1; then
            echo "Attempting to pull ${IMAGE_TAG}"
            docker pull "${IMAGE_TAG}" || {
              echo "::notice::Image pull failed or not available"
            }
          else
            echo "::notice::Docker not available on consumer runner"
          fi

  # Cleanup old artifacts to manage storage
  cleanup:
    name: Cleanup old artifacts
    needs: [build, publish, consume]
    runs-on: ubuntu-latest
    if: ${{ always() && github.event_name != 'pull_request' }}
    permissions:
      actions: write
    steps:
      - name: Prune old CI artifacts
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          script: |
            const maxArtifacts = 5;  // Keep last 5 builds
            const artifactName = "app_bundle";
            
            const artifacts = await github.rest.actions.listArtifactsForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100,
            });
            
            const candidates = artifacts.data.artifacts
              .filter((artifact) => artifact.name === artifactName && !artifact.expired)
              .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
            
            const toDelete = candidates.slice(maxArtifacts);
            
            if (toDelete.length === 0) {
              core.info(`No ${artifactName} artifacts require pruning.`);
              return;
            }
            
            for (const artifact of toDelete) {
              core.info(`Deleting old artifact ${artifact.id} from ${artifact.created_at}`);
              try {
                await github.rest.actions.deleteArtifact({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  artifact_id: artifact.id,
                });
              } catch (error) {
                core.warning(`Failed to delete artifact ${artifact.id}: ${error.message}`);
              }
            }

  # Dependency update check (runs on schedule or manual trigger)
  dependency-check:
    name: Check for dependency updates
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'schedule' || github.event_name == 'workflow_dispatch' }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 1

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Poetry
        run: |
          python -m pip install --upgrade pip
          pip install poetry==2.2.0

      - name: Check for outdated dependencies
        continue-on-error: true
        run: |
          poetry show --outdated --format json > dependency-report.json || {
            echo "::warning::Could not generate dependency report"
            echo "[]" > dependency-report.json
          }

      - name: Generate dependency summary
        run: |
          python - <<'EOF'
          import json
          import os
          from pathlib import Path
          
          report_path = Path('dependency-report.json')
          
          if not report_path.exists():
              print("No dependency report found")
              exit(0)
          
          try:
              data = json.loads(report_path.read_text())
          except:
              print("Failed to parse dependency report")
              exit(0)
          
          if not data:
              summary = "### âœ“ All dependencies are up to date\n"
          else:
              summary = f"### ðŸ“¦ Dependency Updates Available ({len(data)})\n\n"
              for dep in data[:15]:  # Show first 15
                  name = dep.get('name', 'unknown')
                  current = dep.get('version', 'unknown')
                  latest = dep.get('latest', 'unknown')
                  summary += f"- **{name}**: {current} â†’ {latest}\n"
              
              if len(data) > 15:
                  summary += f"\n...and {len(data) - 15} more updates available\n"
              
              summary += "\nðŸ’¡ Run `poetry update` to update dependencies\n"
          
          summary_file = Path(os.environ.get('GITHUB_STEP_SUMMARY', '/dev/null'))
          if summary_file.exists() or summary_file.parent.exists():
              summary_file.write_text(summary)
          
          print(summary)
          EOF

      - name: Upload dependency report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: dependency-report
          path: dependency-report.json
          retention-days: 7
          if-no-files-found: ignore
